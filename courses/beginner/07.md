---
index: 7
title: 7. InSpec Control Enhancements
author: Aaron Lippold
headerDepth: 3
---

## InSpec Control Enhancements

You should have the basic idea of how an InSpec test is written and how to leverage InSpec's built-in features to help you write tests quickly and easily. Now let's discuss some of the more powerful features available to you when writing tests to control what output is displayed to the user.

### rSpec

The InSpec testing framework is itself built on [rSpec](https://rspec.info/), a unit testing module for Ruby. InSpec extended rspec by including features like the resources library and more user-friendly syntax for writing tests, but we can still write our tests using rSpec syntax and they will work just fine.

Most of the time you won't need to use rSpec syntax to write a good test. But we want to show you a few neat tricks you can accomplish with rSpec.

### rSpec Explicit Subject

Let's open up the InSpec shell again to play around with rSpec syntax. First, we'll try a test that _does not_ use rSpec syntax to illustrate the problem we want to solve.

Here we have an InSpec test that lists out its current directory. Our original test code looks like this:

::: code-tabs

@tab Code
```ruby
describe command('ls -al').stdout.strip do
  it { should_not be_empty }
end
```

@tab Output
```sh
✔  total 8
     drwxr-xr-x  4 user  1096267778  128 Feb  3 14:05 .
     drwxr-xr-x  5 user  1096267778  160 Feb  3 11:48 ..
     drwxr-xr-x  4 user  1096267778  128 Feb  3 14:02 controls
     -rw-r--r--  1 user  1096267778   36 Feb  3 14:05 inspec.lock is expected not to be empty
```
:::

Notice how much output InSpec printed here to answer the simple question of "did this command return empty?" Imagine if we had done this on a directory with many files in it. We'd just be cluttering up the screen (and our report files).

If we would like to have a more detailed and cleaner feedback to our user, we can override the standard title of our describe block with a specific message that describes the intent of the test and use the [Explicit Subject](https://relishapp.com/rspec/rspec-core/docs/subject/explicit-subject) to tell inspec what the "subject" is for the test, then, we could refactor the code like this:

::: code-tabs

@tab Code
```ruby
describe "The current directory" do
  subject { command('ls -al').stdout.strip }
  it { should_not be_empty }
end
```


@tab Output

```sh
✔  The current directory is expected not to be empty
```
:::

::: info 
Another benefit to using `subject` is preventing command output from being stored in the report.
:::

### The `should` vs. `expect` syntax

Users familiar with the rSpec testing framework may know that there are two ways to write test statements: `should` and `expect`. The RSpec community decided that `expect` is the preferred syntax.

InSpec recommends the `should` syntax as it tends to read more easily. However, there are times when the `expect` syntax will communicate much more clearly to the end-user.

InSpec will continue to support both methods of writing tests. Consider this file test from your nginx profile:

::: code-tabs

@tab Code
```ruby
describe file('/etc/nginx/nginx.conf') do
  it { should be_file }
end
```

@tab Output
```sh
File /etc/nginx/nginx.conf
   ✔  should be a file
```
:::

This can be re-written with expect syntax

::: code-tabs

@tab Code
```ruby
describe file('/etc/nginx/nginx.conf') do
  it 'should be a file' do
    expect(subject).to(be_file)
  end
end
```

@tab Output
```sh
File /etc/nginx/nginx.conf
   ✔  should be a file
```
:::

Notice that the output is the same for both the examples above.

In addition, you can make use of the `subject` keyword to further control your output if you choose:

::: code-tabs

@tab Code
```ruby
describe 'test file' do
  subject { file('/etc/nginx/nginx.conf') }
  it 'should be a file' do
    expect(subject).to(be_file)
  end
end
```

@tab Output
```sh
test file
  ✔  should be a file
```
:::

::: info
Note that all three of the above code examples are running the same test that will pass or fail in the same circumstances — the difference is that the second two examples give more control over the message output that appears to the test performer. If you write tests that will later be executed by other people, you should be sure to write descriptive test output!
:::

Reference: <https://docs.chef.io/inspec/profiles/>

### `expect` syntax with a failure message

In addition to using an `expect` statement, a failure message can be added to provide a meaningful output to the end user.

Consider this shell access test from your nginx profile:

::: code-tabs

@tab Code
```ruby
describe users.shells(/bash/).usernames do
  it { should be_in input('admin_users')}
end
```

@tab Output
```sh
["root", "codespace"]
  ×  is expected to be in "admin"
  expected `["root", "codespace"]` to be in the list: `["admin"]`
```
:::

The output of a test like this can be refined by providing a cleaner output to the user. This can be done using a custom failure message:

::: code-tabs

@tab Code
```ruby
non_admin_users = users.shells(/bash/).usernames
describe "Shell access for non-admin users" do
  it "should be removed." do
    failure_message = "These non-admin should not have shell access: #{non_admin_users.join(", ")}"
    expect(non_admin_users).to eq(input('admin_users')), failure_message
  end
end
```

@tab Output
```sh
Shell access for non-admin users
  ×  should be removed.
  These non-admin should not have shell access: root, codespace
```
:::

### `Expect` syntax and Password Hashes

Here we have an inspec test that checks if passwords are SHA512 hashes. As a quick thought exercise, can you think of how we can adjust the control below to support SHA512 or higher assuming where you are testing uses SHA1024 or even SHA2048?

As we said, when possible, and when there is a high change of a large set only having a few offending items, attempt to find only those items that could be outside our requirements, if there are none, wonderful, we met our requirement.

```ruby
bad_users = inspec.shadow.where { password != "*" && password != "!" && password !~ /\$6\$/ }.users

describe 'Password hashes in /etc/shadow' do
  it 'should only contain SHA512 hashes' do
    failure_message = "Users without SHA512 hashes: #{bad_users.join(', ')}"
    expect(bad_users).to be_empty, failure_message
  end
end
```

### Looping Through Data

The `file` resource is perfect for looking at single files and their properties, however, it does not look at groups of files. To do that, we need to use multiple resources in concert. Let's use the `command` resource to run the `find` command, or it's equivalent for your target OS, and then use the `file` resource. Using multiple resources together is one of the key values InSpec provides, allowing you to get at just the data you need when you need it.
 
```ruby
command('find ~/* -type f -maxdepth 0 -xdev').stdout.split.each do |fname|
  describe file(fname) do
    its('owner') { should cmp 'ec2-user' }
  end
end
```

::: warning Avoid Large Sets or 'Check Everyone at the Door' Approaches

For IO intensive (full filesystem, or global scans) or large scale processes, try to be as specific as possible with your searches. Think about using 'negative logic' vs 'positive logic' - "Find me all the items outside my target set" vs "Look at each item in the set and ensure it has these properties". 

This 'find the outsiders' vs 'check everyone at the door' approach can really speed things along. Again, keep your data set as small as possible, don't inspect more than the requirements require!

:::