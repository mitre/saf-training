{"version":3,"file":"index.mjs","sources":["../src/plugin.ts"],"sourcesContent":["import { type PluginWithOptions } from \"markdown-it\";\nimport { type RuleBlock } from \"markdown-it/lib/parser_block.js\";\nimport type Token from \"markdown-it/lib/token.js\";\n\nimport { MarkdownItDemoOptions } from \"./options.js\";\n\nexport const demo: PluginWithOptions<MarkdownItDemoOptions> = (\n  md,\n  {\n    name = \"demo\",\n    openRender = (tokens: Token[], index: number): string =>\n      `<details><summary>${tokens[index].info.trim()}</summary>\\n`,\n    closeRender = (): string => \"</details>\\n\",\n    codeRender,\n    beforeContent = false,\n  } = {},\n) => {\n  const MIN_MARKER_NUM = 3;\n\n  const demo: RuleBlock = (state, startLine, endLine, silent) => {\n    let start = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n\n    if (\":\" !== state.src[start]) return false;\n\n    let pos = start + 1;\n\n    // Check out the rest of the marker string\n    while (pos <= max) {\n      if (\":\" !== state.src[pos]) break;\n      pos += 1;\n    }\n\n    const markerCount = pos - start;\n\n    if (markerCount < MIN_MARKER_NUM) return false;\n\n    const markup = state.src.slice(start, pos);\n    const params = state.src.slice(pos, max);\n\n    if (params.trim().split(\" \", 2)[0] !== name) return false;\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine;\n    let autoClosed = false;\n\n    // Search for the end of the block\n    while (\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine\n    ) {\n      nextLine += 1;\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent)\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n\n      if (\n        // match start\n        \":\" === state.src[start] &&\n        // closing fence should be indented less than 4 spaces\n        state.sCount[nextLine] - state.blkIndent < 4\n      ) {\n        // check rest of marker\n        for (pos = start + 1; pos <= max; pos++)\n          if (\":\" !== state.src[pos]) break;\n\n        // closing code fence must be at least as long as the opening one\n        if (Math.floor(pos - start) >= markerCount) {\n          // make sure tail has spaces only\n          pos = state.skipSpaces(pos);\n\n          if (pos >= max) {\n            // found!\n            autoClosed = true;\n            break;\n          }\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n\n    // @ts-expect-error\n    state.parentType = \"container\";\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    const title = params.trim().slice(name.length).trim();\n    const openToken = state.push(\"demo_open\", \"div\", 1);\n\n    openToken.markup = markup;\n    openToken.block = true;\n    openToken.info = title;\n    openToken.map = [startLine, nextLine];\n\n    const pushCodeToken = (): void => {\n      const codeToken = state.push(\n        codeRender ? \"demo_code\" : \"fence\",\n        \"code\",\n        0,\n      );\n\n      const indent = state.sCount[startLine];\n\n      codeToken.content = state.src\n        .split(/\\n\\r?/)\n        .slice(startLine + 1, nextLine)\n        .map((line) => line.substring(indent))\n        .join(\"\\n\")\n        .replace(/^\\n+/, \"\")\n        .replace(/\\n*$/, \"\\n\");\n      codeToken.map = [startLine, state.line];\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      (codeToken.meta ??= {}).title = title;\n      if (!codeRender) codeToken.info = \"md\";\n    };\n\n    if (beforeContent) pushCodeToken();\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    if (!beforeContent) pushCodeToken();\n\n    const closeToken = state.push(`demo_close`, \"div\", -1);\n\n    closeToken.markup = state.src.slice(start, pos);\n    closeToken.block = true;\n    closeToken.info = title;\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\n  md.block.ruler.before(\"fence\", \"demo\", demo, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n  md.renderer.rules[\"demo_open\"] = openRender;\n  md.renderer.rules[\"demo_close\"] = closeRender;\n  if (codeRender) md.renderer.rules[\"demo_code\"] = codeRender;\n};\n"],"names":["demo","md","name","openRender","tokens","index","closeRender","codeRender","beforeContent","state","startLine","endLine","silent","start","max","pos","markerCount","markup","params","nextLine","autoClosed","oldParent","oldLineMax","title","openToken","pushCodeToken","codeToken","indent","line","closeToken"],"mappings":"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"}