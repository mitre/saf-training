TEMP STORAGE FOR NONGUIDED LABS TO BE ADDED LATER

### Mapper Demo - JFrog

This section is yet another example of implementing an OHDF mapper, namely the JFrog-Xray mapper. Again, we will assume that the [appropriate file set up for the mapper](#file-set-up) has been performed. Because we have already gone through several examples, this section will not explain too many things in detail. The goal is to simply provide more examples for reference.

Here is our developed mapping for JFrog-Xray for reference:

::: details JFrog-to-OHDF Mapping

```typescript
{
  platform: {
    name: 'Heimdall Tools',
    release: HeimdallToolsVersion,
    target_id
  },
  version: HeimdallToolsVersion,
  statistics: {
    duration
  },
  profiles: [
    {
      name,
      version,
      sha256,
      title,
      maintainer,
      summary,
      license,
      copyright,
      copyright_email,
      supports,
      attributes,
      groups,
      controls: [
        {
          id: 'data.id',         // If ID empty, hash the summary
          title: 'data.summary',
          desc: 'component_versions.more_details',
          descriptions,
          impact: 'data.severity',
          refs,
          tags: {
            nist: 'data.component_versions.more_details.cves[0].cwe', // Map to NIST
            cci: 'data.component_versions.more_details.cves[0].cwe', // Map to CCI
            cweid: 'data.component_versions.more_details.cves[0].cwe'
          },
          code,
          source_location,
          results: [
            {
              status: 'Failed', // All reported findings are failures
              code_desc: ['data.source_comp_id', 'data.component_versions.vulnerable_versions', 'data.component_versions.fixed_versions', 'data.issue_type', 'data.provider'],
              message,
              run_time,
              start_time
            }
          ]
        },
      ],
      status: 'loaded'
    },
  ],
  passthrough: {
    auxiliary_data: [
      {
        name,
        data
      },
    ],
    raw
  }
}
```

:::

::: details JFrog Source Data

```json
{
  "total_count": 30,
  "data": [
    {
      "id": "",
      "severity": "High",
      "summary": "Acorn regexp.js Regular Expression Validation UTF-16 Surrogate Handling Infinite Loop DoS",
      "issue_type": "security",
      "provider": "JFrog",
      "component": "acorn",
      "source_id": "npm://acorn",
      "source_comp_id": "npm://acorn:5.7.3",
      "component_versions": {
        "id": "acorn",
        "vulnerable_versions": [
          "5.5.0 ≤ Version < 5.7.4",
          "6.0.0 ≤ Version < 6.4.1",
          "7.0.0",
          "7.1.0"
        ],
        "fixed_versions": ["5.7.4", "6.4.1", "7.1.1"],
        "more_details": {
          "cves": [
            {
              "cvss_v2": "7.1/AV:N/AC:M/Au:N/C:N/I:N/A:C",
              "cvss_v3": "7.5/CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
            }
          ],
          "description": "Acorn contains an infinite loop condition in regexp.js that is triggered when handling UTF_16 surrogates while validating regular expressions. This may allow a context-dependent attacker to hang a process using the library.",
          "provider": "JFrog"
        }
      },
      "edited": "2020-11-03T19:30:42-05:00"
    }
  ]
}
```

:::

We will now go over the mapper code that allows us to shape this data properly. Firstly, let us handle the ID. Sometimes, JFrog source files will not have an ID field. In this case, it is appropriate to generate a hash based on the `summary` as follows:

```typescript
function hashId(vulnerability: unknown): string {
  if (_.get(vulnerability, "id") === "") {
    return generateHash(
      (_.get(vulnerability, "summary") as unknown as string).toString(),
      "md5"
    );
  } else {
    return _.get(vulnerability, "id") as unknown as string;
  }
}
```

As with most mappers, we must also define an impact mapping:

```typescript
const IMPACT_MAPPING: Map<string, number> = new Map([
  ["high", 0.7],
  ["medium", 0.5],
  ["low", 0.3],
]);
```

Recall that we wanted to format the `desc` field based on the data in the source file's `component_versions.more_details`. We can write a simple transformer function to concatenate all these keys:

```typescript
function formatDesc(vulnerability: unknown): string {
  const text = [];
  if (_.has(vulnerability, "description")) {
    text.push(
      (_.get(vulnerability, "description") as unknown as string).toString()
    );
  }
  if (_.has(vulnerability, "cves")) {
    const re1 = /":/gi;
    const re2 = /,/gi;
    text.push(
      `cves: ${JSON.stringify(_.get(vulnerability, "cves"))
        .replace(re1, '"=>')
        .replace(re2, ", ")}`
    );
  }
  return text.join("<br>");
}
```

We also must properly handle the mappings to NIST and CCI tags. Luckily, we can make use of the library's existing mappings, as well as an existing global function called `getCCIsForNISTTags()` in `global.ts`.

```typescript
const CWE_PATH = "component_versions.more_details.cves[0].cwe";
const CWE_NIST_MAPPING = new CweNistMapping();

function nistTag(identifier: Record<string, unknown>): string[] {
  const identifiers: string[] = [];
  if (Array.isArray(identifier)) {
    identifier.forEach((element) => {
      if (element.split("CWE-")[1]) {
        identifiers.push(element.split("CWE-")[1]);
      }
    });
  }
  return CWE_NIST_MAPPING.nistFilter(
    identifiers,
    DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS
  );
}
```

Finally, we can implement the transformer function for the `code_desc`. Some of these fields are optional, so it is important to implement a base case to ensure our `code_desc` outputs are all consistent.

```typescript
function formatCodeDesc(vulnerability: unknown): string {
  const codeDescArray: string[] = [];
  const re = /,/gi;
  if (_.has(vulnerability, "source_comp_id")) {
    codeDescArray.push(
      `source_comp_id : ${_.get(vulnerability, "source_comp_id")}`
    );
  } else {
    codeDescArray.push("source_comp_id : ");
  }
  if (_.has(vulnerability, "component_versions.vulnerable_versions")) {
    codeDescArray.push(
      `vulnerable_versions : ${JSON.stringify(
        _.get(vulnerability, "component_versions.vulnerable_versions")
      )}`
    );
  } else {
    codeDescArray.push("vulnerable_versions : ");
  }
  if (_.has(vulnerability, "component_versions.fixed_versions")) {
    codeDescArray.push(
      `fixed_versions : ${JSON.stringify(
        _.get(vulnerability, "component_versions.fixed_versions")
      )}`
    );
  } else {
    codeDescArray.push("fixed_versions : ");
  }
  if (_.has(vulnerability, "issue_type")) {
    codeDescArray.push(`issue_type : ${_.get(vulnerability, "issue_type")}`);
  } else {
    codeDescArray.push("issue_type : ");
  }
  if (_.has(vulnerability, "provider")) {
    codeDescArray.push(`provider : ${_.get(vulnerability, "provider")}`);
  } else {
    codeDescArray.push("provider : ");
  }
  return codeDescArray.join("\n").replace(re, ", ");
}
```

All that's left is to incoporate all these functions into our `base-converter` structure, write some smaller transformer functions for the simpler data formatting tasks, and combine it all together!

:::details Full Mapper Code

```typescript
import { ExecJSON } from "inspecjs";
import * as _ from "lodash";
import { version as HeimdallToolsVersion } from "../package.json";
import {
  BaseConverter,
  generateHash,
  ILookupPath,
  impactMapping,
  MappedTransform,
} from "./base-converter";
import { CweNistMapping } from "./mappings/CweNistMapping";
import {
  DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS,
  getCCIsForNISTTags,
} from "./utils/global";

// Constants
const IMPACT_MAPPING: Map<string, number> = new Map([
  ["high", 0.7],
  ["medium", 0.5],
  ["low", 0.3],
]);

const CWE_PATH = "component_versions.more_details.cves[0].cwe";

const CWE_NIST_MAPPING = new CweNistMapping();

// Transformation Functions
function hashId(vulnerability: unknown): string {
  if (_.get(vulnerability, "id") === "") {
    return generateHash(
      (_.get(vulnerability, "summary") as unknown as string).toString(),
      "md5"
    );
  } else {
    return _.get(vulnerability, "id") as unknown as string;
  }
}
function formatDesc(vulnerability: unknown): string {
  const text = [];
  if (_.has(vulnerability, "description")) {
    text.push(
      (_.get(vulnerability, "description") as unknown as string).toString()
    );
  }
  if (_.has(vulnerability, "cves")) {
    const re1 = /":/gi;
    const re2 = /,/gi;
    text.push(
      `cves: ${JSON.stringify(_.get(vulnerability, "cves"))
        .replace(re1, '"=>')
        .replace(re2, ", ")}`
    );
  }
  return text.join("<br>");
}
function formatCodeDesc(vulnerability: unknown): string {
  const codeDescArray: string[] = [];
  const re = /,/gi;
  if (_.has(vulnerability, "source_comp_id")) {
    codeDescArray.push(
      `source_comp_id : ${_.get(vulnerability, "source_comp_id")}`
    );
  } else {
    codeDescArray.push("source_comp_id : ");
  }
  if (_.has(vulnerability, "component_versions.vulnerable_versions")) {
    codeDescArray.push(
      `vulnerable_versions : ${JSON.stringify(
        _.get(vulnerability, "component_versions.vulnerable_versions")
      )}`
    );
  } else {
    codeDescArray.push("vulnerable_versions : ");
  }
  if (_.has(vulnerability, "component_versions.fixed_versions")) {
    codeDescArray.push(
      `fixed_versions : ${JSON.stringify(
        _.get(vulnerability, "component_versions.fixed_versions")
      )}`
    );
  } else {
    codeDescArray.push("fixed_versions : ");
  }
  if (_.has(vulnerability, "issue_type")) {
    codeDescArray.push(`issue_type : ${_.get(vulnerability, "issue_type")}`);
  } else {
    codeDescArray.push("issue_type : ");
  }
  if (_.has(vulnerability, "provider")) {
    codeDescArray.push(`provider : ${_.get(vulnerability, "provider")}`);
  } else {
    codeDescArray.push("provider : ");
  }
  return codeDescArray.join("\n").replace(re, ", ");
}
function nistTag(identifier: Record<string, unknown>): string[] {
  const identifiers: string[] = [];
  if (Array.isArray(identifier)) {
    identifier.forEach((element) => {
      if (element.split("CWE-")[1]) {
        identifiers.push(element.split("CWE-")[1]);
      }
    });
  }
  return CWE_NIST_MAPPING.nistFilter(
    identifiers,
    DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS
  );
}

// Mappings
export class JfrogXrayMapper extends BaseConverter {
  withRaw: boolean;

  mappings: MappedTransform<
    ExecJSON.Execution & { passthrough: unknown },
    ILookupPath
  > = {
    platform: {
      name: "Heimdall Tools",
      release: HeimdallToolsVersion,
    },
    version: HeimdallToolsVersion,
    statistics: {},
    profiles: [
      {
        name: "JFrog Xray Scan",
        title: "JFrog Xray Scan",
        summary: "Continuous Security and Universal Artifact Analysis",
        supports: [],
        attributes: [],
        groups: [],
        status: "loaded",
        controls: [
          {
            path: "data",
            key: "id",
            tags: {
              cci: {
                path: CWE_PATH,
                transformer: (identifier: Record<string, unknown>) =>
                  getCCIsForNISTTags(nistTag(identifier)),
              },
              nist: {
                path: CWE_PATH,
                transformer: nistTag,
              },
              cweid: { path: CWE_PATH },
            },
            refs: [],
            source_location: {},
            id: { transformer: hashId },
            title: { path: "summary" },
            desc: {
              path: "component_versions.more_details",
              transformer: formatDesc,
            },
            impact: {
              path: "severity",
              transformer: impactMapping(IMPACT_MAPPING),
            },
            code: {
              transformer: (vulnerability: Record<string, unknown>): string => {
                return JSON.stringify(vulnerability, null, 2);
              },
            },
            results: [
              {
                status: ExecJSON.ControlResultStatus.Failed,
                code_desc: { transformer: formatCodeDesc },
                start_time: "",
              },
            ],
          },
        ],
        sha256: "",
      },
    ],
    passthrough: {
      transformer: (data: Record<string, unknown>): Record<string, unknown> => {
        return {
          auxiliary_data: [
            {
              name: "JFrog Xray",
              data: _.pick(data, ["total_count"]),
            },
          ],
          ...(this.withRaw && { raw: data }),
        };
      },
    },
  };
  constructor(xrayJson: string, withRaw = false) {
    super(JSON.parse(xrayJson), true);
    this.withRaw = withRaw;
  }
}
```

:::

Now we have a fully implemented JFrog-to-OHDF mapper.

### Mapper Demo - SARIF

Here is one last example of implementing an OHDF mapper - the SARIF mapper. As in previous examples, we will assume that the [appropriate file set up for the mapper](#file-set-up) has been performed. Like with the JFrog example, we will not be going into too much detail regarding the mapping itself. The goal is to simply provide more examples for reference.

Here is our developed mapping for SARIF for reference:

::: details SARIF-to-OHDF Mapping

```typescript
{
  platform: {
    name: 'Heimdall Tools',
    release: HeimdallToolsVersion,
    target_id
  },
  version: HeimdallToolsVersion,
  statistics: {
    duration
  },
  profiles: [
    {
      name,
      version: 'version',
      sha256,
      title,
      maintainer,
      summary,
      license,
      copyright,
      copyright_email,
      supports,
      attributes,
      groups,
      controls: [
        {
          id: 'results.ruleId',         // If ID empty, hash the summary
          title: 'results.message.text',
          desc: 'results.message.text',
          descriptions,
          impact: 'results.level',
          refs,
          tags: {
            nist: 'results.message.text', // Map to NIST
            cci: 'results.message.text', // Map to CCI
            cwe: 'results.message.text'
          },
          code,
          source_location: ['results.locations[0].physicalLocation.artifactLocation.uri', 'results.locations[0].physicalLocation.region.startLine'],
          results: [
            {
              status: 'Failed', // All reported findings are failures
              code_desc: 'results.locations[0].physicalLocation',
              message,
              run_time,
              start_time
            }
          ]
        },
      ],
      status: 'loaded'
    },
  ],
  passthrough: {
    auxiliary_data: [
      {
        name,
        data
      },
    ],
    raw
  }
}
```

:::

::: details SARIF Source Data

```json
{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.5.json",
  "version": "2.1.0",
  "runs": [
    {
      "results": [
        {
          "ruleId": "FF1014",
          "level": "error",
          "message": {
            "text": "buffer/gets: Does not check for buffer overflows (CWE-120, CWE-20)."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "test/test-patched.c",
                  "uriBaseId": "SRCROOT"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 2,
                  "endColumn": 10,
                  "snippet": {
                    "text": " gets(f);"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "contextHash/v1": "6a5bb383fb44030b0d9428b17359e94ba3979bc1ce702be450427f85592c649a"
          },
          "rank": 1
        }
      ]
    }
  ]
}
```

:::

First, let us define some common constants that might help us with our code.

```typescript
const MESSAGE_TEXT = "message.text";
const CWE_NIST_MAPPING = new CweNistMapping();
```

We will now outline the `IMPACT_MAPPING` for the SARIF mapper:

```typescript
const IMPACT_MAPPING: Map<string, number> = new Map([
  ["error", 0.7],
  ["warning", 0.5],
  ["note", 0.3],
]);

function impactMapping(severity: unknown): number {
  if (typeof severity === "string" || typeof severity === "number") {
    return IMPACT_MAPPING.get(severity.toString().toLowerCase()) || 0.1;
  } else {
    return 0.1;
  }
}
```

Now, note that we will need to extract the CWEs from the message text, as well as map them to the proper NIST tags. For the CCIs, we can again use the global function `getCCIsForNISTTags()`.

```typescript
function extractCwe(text: string): string[] {
  let output = text.split("(").slice(-1)[0].slice(0, -2).split(", ");
  if (output.length === 1) {
    output = text.split("(").slice(-1)[0].slice(0, -2).split("!/");
  }
  return output;
}
function nistTag(text: string): string[] {
  let identifiers = extractCwe(text);
  identifiers = identifiers.map((element) => element.split("-")[1]);
  return CWE_NIST_MAPPING.nistFilter(
    identifiers,
    DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS
  );
}
```

Our last standalone transformer function will format our code description. This part is up to interpretation, but we decided to just concatenate them all with colon-separated key-value pairs

```typescript
function formatCodeDesc(input: unknown): string {
  const output = [];
  output.push(`URL : ${_.get(input, "artifactLocation.uri")}`);
  output.push(`LINE : ${_.get(input, "region.startLine")}`);
  output.push(`COLUMN : ${_.get(input, "region.startColumn")}`);
  return output.join(" ");
}
```

Now, all that's left is to combine our functions, write some mini-transformers for the small data formatting, and plug it all into the base converter!

:::details Full Mapper Code

```typescript
import { ExecJSON } from "inspecjs";
import * as _ from "lodash";
import { version as HeimdallToolsVersion } from "../package.json";
import { BaseConverter, ILookupPath, MappedTransform } from "./base-converter";
import { CweNistMapping } from "./mappings/CweNistMapping";
import {
  DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS,
  getCCIsForNISTTags,
} from "./utils/global";

const IMPACT_MAPPING: Map<string, number> = new Map([
  ["error", 0.7],
  ["warning", 0.5],
  ["note", 0.3],
]);
const MESSAGE_TEXT = "message.text";
const CWE_NIST_MAPPING = new CweNistMapping();

function extractCwe(text: string): string[] {
  let output = text.split("(").slice(-1)[0].slice(0, -2).split(", ");
  if (output.length === 1) {
    output = text.split("(").slice(-1)[0].slice(0, -2).split("!/");
  }
  return output;
}
function impactMapping(severity: unknown): number {
  if (typeof severity === "string" || typeof severity === "number") {
    return IMPACT_MAPPING.get(severity.toString().toLowerCase()) || 0.1;
  } else {
    return 0.1;
  }
}
function formatCodeDesc(input: unknown): string {
  const output = [];
  output.push(`URL : ${_.get(input, "artifactLocation.uri")}`);
  output.push(`LINE : ${_.get(input, "region.startLine")}`);
  output.push(`COLUMN : ${_.get(input, "region.startColumn")}`);
  return output.join(" ");
}
function nistTag(text: string): string[] {
  let identifiers = extractCwe(text);
  identifiers = identifiers.map((element) => element.split("-")[1]);
  return CWE_NIST_MAPPING.nistFilter(
    identifiers,
    DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS
  );
}

export class SarifMapper extends BaseConverter {
  withRaw: boolean;

  mappings: MappedTransform<
    ExecJSON.Execution & { passthrough: unknown },
    ILookupPath
  > = {
    platform: {
      name: "Heimdall Tools",
      release: HeimdallToolsVersion,
      target_id: "Static Analysis Results Interchange Format",
    },
    version: HeimdallToolsVersion,
    statistics: {},
    profiles: [
      {
        path: "runs",
        name: "SARIF",
        version: { path: "$.version" },
        title: "Static Analysis Results Interchange Format",
        supports: [],
        attributes: [],
        groups: [],
        status: "loaded",
        controls: [
          {
            path: "results",
            key: "id",
            tags: {
              cci: {
                path: MESSAGE_TEXT,
                transformer: (data: string) =>
                  getCCIsForNISTTags(nistTag(data)),
              },
              nist: { path: MESSAGE_TEXT, transformer: nistTag },
              cwe: {
                path: MESSAGE_TEXT,
                transformer: extractCwe,
              },
            },
            refs: [],
            source_location: {
              transformer: (control: unknown) => {
                return _.omitBy(
                  {
                    ref: _.get(
                      control,
                      "locations[0].physicalLocation.artifactLocation.uri"
                    ),
                    line: _.get(
                      control,
                      "locations[0].physicalLocation.region.startLine"
                    ),
                  },
                  (value) => value === ""
                );
              },
            },
            title: {
              path: MESSAGE_TEXT,
              transformer: (text: unknown): string => {
                if (typeof text === "string") {
                  return text.split(": ")[0];
                } else {
                  return "";
                }
              },
            },
            id: { path: "ruleId" },
            desc: {
              path: MESSAGE_TEXT,
              transformer: (text: unknown): string => {
                if (typeof text === "string") {
                  return text.split(": ")[1];
                } else {
                  return "";
                }
              },
            },
            impact: { path: "level", transformer: impactMapping },
            code: {
              transformer: (vulnerability: Record<string, unknown>): string =>
                JSON.stringify(vulnerability, null, 2),
            },
            results: [
              {
                status: ExecJSON.ControlResultStatus.Failed,
                code_desc: {
                  path: "locations[0].physicalLocation",
                  transformer: formatCodeDesc,
                },

                start_time: "",
              },
            ],
          },
        ],
        sha256: "",
      },
    ],
    passthrough: {
      transformer: (data: Record<string, unknown>): Record<string, unknown> => {
        let runsData = _.get(data, "runs");
        if (Array.isArray(runsData)) {
          runsData = runsData.map((run: Record<string, unknown>) =>
            _.omit(run, ["results"])
          );
        }
        return {
          auxiliary_data: [
            {
              name: "SARIF",
              data: {
                $schema: _.get(data, "$schema"),
                runs: runsData,
              },
            },
          ],
          ...(this.withRaw && { raw: data }),
        };
      },
    },
  };
  constructor(sarifJson: string, withRaw = false) {
    super(JSON.parse(sarifJson));
    this.withRaw = withRaw;
  }
}
```

:::

Now we have a fully implemented SARIF-to-OHDF mapper.
