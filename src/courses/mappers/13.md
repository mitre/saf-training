---
order: 13
next: 14.md
title: Demo - Mapping a Schema
author: Charles Hu
---

## Mapping Introduction

::: note Security Tool Type
This walkthrough is targeted at converting security scans to OHDF. If your security tool provides exports that are not security scans or are APIs, contact the SAF team for further instruction on how to develop those services into a OHDF mapper.
:::

We begin the creation of every OHDF mapper by first planning out how we want correlate the fields in the OHDF and security tool's schemas. This mapping is important for the following reasons:

1. It gives us a good framework for guiding how we actually implement the *-to-OHDF mapper.
2. It notifies us of potential knowledge gaps we may have of a security tool's schema. We need to close these gaps as best as we can in order to ensure that we can create schema field correlations that are as accurate/applicable as possible.
3. It gives us a chance to review our mapping of the schemas in a format that is still human readable.
4. It helps us reduce the amount of corrections and rewrites we have to perform on the actual mapper implementation due to schema mapping errors.

As we develop the mappings in the following examples, note that we will break down and analyze the schemas according to the OHDF schema structures we previously learned about (<i>profiles</i>, <i>controls</i>, and <i>results</i>). This is not necessarily the only or the best way to do this and you are encouraged to develop your own methods for correlating schemas that work best for you.

::: note Use of Exported Security Tool Data
The following examples will use generated instances of exported security tool data that do not reflect the entirety of the schemas they are based on. Ideally, you will want to use the full schema when creating a mapping; however, the full schema is typically not readily available. To reflect this, we will be using generated export data and will fill in missing schema data when possible.
:::

## Mapping Demo - GoSec

### 1. Breaking Down the Data

Let's first start with our GoSec sample, which you should be already familiar with:

::: details GoSec Source Data
```json
{
  "Golang errors": {},
  "Issues": [
    {
      "severity": "MEDIUM",
      "confidence": "HIGH",
      "cwe": {
        "id": "22",
        "url": "https://cwe.mitre.org/data/definitions/22.html"
      },
      "rule_id": "G304",
      "details": "Potential file inclusion via variable",
      "file": "C:\\Users\\AGILLUM\\OneDrive - The MITRE Corporation\\Documents\\Code\\grype-0.34.4\\internal\\file\\tar.go",
      "code": "82: \t\tcase tar.TypeReg:\n83: \t\t\tf, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(header.Mode))\n84: \t\t\tif err != nil {\n",
      "line": "83",
      "column": "14",
      "nosec": false,
      "suppressions": null
    }
  ],
  "Stats": {
    "files": 199,
    "lines": 12401,
    "nosec": 0,
    "found": 7
  },
  "GosecVersion": "dev"
}
```
:::

We can begin our mapping process by identifying the purpose of each field in the source data according to the [schema for GoSec](https://github.com/securego/gosec/blob/master/issue/issue.go). While we do this, it's also important that we try to tie back each identified purpose to the three general OHDF schema structures that we learned about earlier; that is, in addition to finding the purpose of each field, we should also ask ourselves the following:

- Is this field recording meta data?
- Is this field recording requirements?
- Is this field recording requirement testing?

To summarize, we should be asking ourselves the following two questions for each field in the source data:

- What is the purpose of this field?
- What is this field recording (meta data, requirements, requirement testing)?

Let's apply this to our GoSec source data. Try to find the answers to these two questions for each field yourself and then refer back to our annotated solution to check your work.

::: details GoSec Annotated Source Data
```json
{
  // Purpose: Go compilation errors
  // Recording: Meta data - Not specifically related to the requirements and will be already recorded as a security issue in 'Issues' if critical
  "Golang errors": {},
  // Purpose: Container for identified security issues
  // Recording: Requirements - This entity records all identified security issues in a Go source code
  "Issues": [
    {
      // Purpose: The severity of the identified issue
      // Recording: Requirements - This is specifically related to the severity level of the requirement
      "severity": "MEDIUM",
      // Purpose: How sure that the identified issue if applicable to this source code
      // Recording: Requirements testing - This field gives the applicability of the issue after source code testing
      "confidence": "HIGH",
      // Purpose: The associated CWE for the security issue
      // Recording: Requirements - This gives the associated CWE for the security issue
      "cwe": {
        "id": "22",
        "url": "https://cwe.mitre.org/data/definitions/22.html"
      },
      // Purpose: The internal GoSec ID for the security issue
      // Recording: Requirements - This gives an ID for the security issue
      "rule_id": "G304",
      // Purpose: Explanation of the security issue
      // Recording: Requirements - This explains the security issue
      "details": "Potential file inclusion via variable",
      // Purpose: The offending file
      // Recording: Requirement testing - This specifically notes which file fails the requirement after source code testing
      "file": "C:\\Users\\AGILLUM\\OneDrive - The MITRE Corporation\\Documents\\Code\\grype-0.34.4\\internal\\file\\tar.go",
      // Purpose: The offending code
      // Recording: Requirement testing - This specifies the code that fails the requirement after source code testing
      "code": "82: \t\tcase tar.TypeReg:\n83: \t\t\tf, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(header.Mode))\n84: \t\t\tif err != nil {\n",
      // Purpose: The line number of the offending code
      // Recording: Requirement testing - This field specifies the location of the failling code
      "line": "83",
      // Purpose: The column number of the offending code
      // Recording: Requirement testing - This field specifies the location of the failling code
      "column": "14",
      // Purpose: Whether this security issue should be ignored
      // Recording: Requirements - Specifies whether this security issue should be ignored
      "nosec": false,
      // Purpose: The supression level for info on the security issue
      // Recording: Requirements - Specifies the info suppression level of the security issue
      "suppressions": null
    }
  ],
  // Purpose: The statistics of the GoSec scan on the source code
  // Recording: Meta data - Info on the scan itself
  "Stats": {
    "files": 199,
    "lines": 12401,
    "nosec": 0,
    "found": 7
  },
  // Purpose: The version of the GoSec instance currently running
  // Recording: Meta data - Info on the scan itself
  "GosecVersion": "dev"
}
```
:::

Note that this process is subjective and your answers may vary from ours. Don't be so quick to backtrack on your own answers, as your solutions may be as equally valid as ours. There is no objective answer to this process and what's important is that you can identify and break down the source data into useful pieces that we can correlate back to the OHDF schema.

### 2. Correlating the Schemas

Now that we're familiar with the specifics of the GoSec schema, we can begin to map these fields to the OHDF schema.

Note that since we used an export from GoSec and are not basing our mapping off the full schema, we will inevitably miss some fields. We can rectify this by adding them into our mapping post hoc whenever needed; however, we can still capture these missed fields without manual intervention by using our `passthrough` field to capture unmapped data.

Let's first start with an empty OHDF schema as follows:

::: details Empty OHDF Schema
```typescript
{
  platform: {
    name,
    release,
    target_id
  },
  version,
  statistics: {
    duration
  },
  profiles: [
    {
      name,
      version,
      sha256,
      title,
      maintainer,
      summary,
      license,
      copyright,
      copyright_email,
      supports,
      attributes,
      groups,
      controls: [
        {
          id,
          title,
          desc,
          descriptions,
          impact,
          refs,
          tags,
          code,
          source_location,
          results: [
            {
              status,
              code_desc,
              message,
              run_time,
              start_time
            }
          ]
        },
      ],
      status
    },
  ],
  passthrough: {
    auxiliary_data: [
      {
        name,
        data
      },
    ],
    raw
  }
}
```
:::

We can begin our schema correlation by directly porting over fields from the GoSec source data that are obvious: `GosecVersion`, `Issues.rule_id`, `Issues.details`, `Issues.cwe`, and `Issues.code`. Try to map these fields youself as you follow along and refer to our solution to check your work.

::: details OHDF Schema Mapping Ver. 1
```typescript
{
  platform: {
    name,
    release,
    target_id
  },
  version,
  statistics: {
    duration
  },
  profiles: [
    {
      name,
      version: GosecVersion,          // Version of GoSec instance
      sha256,
      title,
      maintainer,
      summary,
      license,
      copyright,
      copyright_email,
      supports,
      attributes,
      groups,
      controls: [
        {
          id: Issues.rule_id,         // ID of the requirement
          title: Issues.details,      // Human readable title for the requirement
          desc,
          descriptions,
          impact,
          refs,
          tags: {
            Issues.cwe                // Associated CWE for the requirement
          },
          code,
          source_location,
          results: [
            {
              status,
              code_desc: Issues.code, // The code for the requirement test
              message,
              run_time,
              start_time
            }
          ]
        },
      ],
      status
    },
  ],
  passthrough: {
    auxiliary_data: [
      {
        name,
        data
      },
    ],
    raw
  }
}
```
:::

::: details Remaining GoSec Source Data
```json
{
  // Purpose: Go compilation errors
  // Recording: Meta data - Not specifically related to the requirements and will be already recorded as a security issue in 'Issues' if critical
  "Golang errors": {},
  // Purpose: Container for identified security issues
  // Recording: Requirements - This entity records all identified security issues in a Go source code
  "Issues": [
    {
      // Purpose: The severity of the identified issue
      // Recording: Requirements - This is specifically related to the severity level of the requirement
      "severity": "MEDIUM",
      // Purpose: How sure that the identified issue if applicable to this source code
      // Recording: Requirements testing - This field gives the applicability of the issue after source code testing
      "confidence": "HIGH",
      // Purpose: The offending file
      // Recording: Requirement testing - This specifically notes which file fails the requirement after source code testing
      "file": "C:\\Users\\AGILLUM\\OneDrive - The MITRE Corporation\\Documents\\Code\\grype-0.34.4\\internal\\file\\tar.go",
      // Purpose: The line number of the offending code
      // Recording: Requirement testing - This field specifies the location of the failling code
      "line": "83",
      // Purpose: The column number of the offending code
      // Recording: Requirement testing - This field specifies the location of the failling code
      "column": "14",
      // Purpose: Whether this security issue should be ignored
      // Recording: Requirements - Specifies whether this security issue should be ignored
      "nosec": false,
      // Purpose: The supression level for info on the security issue
      // Recording: Requirements - Specifies the info suppression level of the security issue
      "suppressions": null
    }
  ],
  // Purpose: The statistics of the GoSec scan on the source code
  // Recording: Meta data - Info on the scan itself
  "Stats": {
    "files": 199,
    "lines": 12401,
    "nosec": 0,
    "found": 7
  }
}
```
:::

Note that these mapping are informal and do not need to adhere to any programming syntax. Proper implementation of these mappings will be done later in the course.

Next, let's look at the fields `Issues.severity`, `Issues.confidence`, `Issues.nosec`, and `Issues.suppressions`.

::: details OHDF Schema Mapping Ver. 2
```typescript
{
  platform: {
    name,
    release,
    target_id
  },
  version,
  statistics: {
    duration
  },
  profiles: [
    {
      name,
      version: GosecVersion,          // Version of GoSec instance
      sha256,
      title,
      maintainer,
      summary,
      license,
      copyright,
      copyright_email,
      supports,
      attributes,
      groups,
      controls: [
        {
          id: Issues.rule_id,         // ID of the requirement
          title: Issues.details,      // Human readable title for the requirement
          desc,
          descriptions,
          impact,
          refs,
          tags: {
            Issues.cwe                // Associated CWE for the requirement
            Issues.severity,          // Severity of the requirement
            Issues.confidence,        // Applicability of the requirement
            Issues.nosec,             // Whether to ignore the requirement
            Issues.suppressions       // Info suppression level of the requirement
          },
          code,
          source_location,
          results: [
            {
              status,
              code_desc: Issues.code, // The code for the requirement test
              message,
              run_time,
              start_time
            }
          ]
        },
      ],
      status
    },
  ],
  passthrough: {
    auxiliary_data: [
      {
        name,
        data
      },
    ],
    raw
  }
}
```
:::

::: details Remaining GoSec Source Data
```json
{
  // Purpose: Go compilation errors
  // Recording: Meta data - Not specifically related to the requirements and will be already recorded as a security issue in 'Issues' if critical
  "Golang errors": {},
  // Purpose: Container for identified security issues
  // Recording: Requirements - This entity records all identified security issues in a Go source code
  "Issues": [
    {
      // Purpose: The offending file
      // Recording: Requirement testing - This specifically notes which file fails the requirement after source code testing
      "file": "C:\\Users\\AGILLUM\\OneDrive - The MITRE Corporation\\Documents\\Code\\grype-0.34.4\\internal\\file\\tar.go",
      // Purpose: The line number of the offending code
      // Recording: Requirement testing - This field specifies the location of the failling code
      "line": "83",
      // Purpose: The column number of the offending code
      // Recording: Requirement testing - This field specifies the location of the failling code
      "column": "14"
    }
  ],
  // Purpose: The statistics of the GoSec scan on the source code
  // Recording: Meta data - Info on the scan itself
  "Stats": {
    "files": 199,
    "lines": 12401,
    "nosec": 0,
    "found": 7
  }
}
```
:::

We map these fields to `tags` in the OHDF schema due to each of these fields acting as descriptive traits of the control which we can categorize and sort the controls by. We won't use `Issues.severity` for `impact` as we have no concrete correlation between the two fields and as such cannot accurately convert between the two.

Next, let's look at the fields `Issues.file`, `Issues.line`, and `Issues.column`.

::: details OHDF Schema Mapping Ver. 3
```typescript
{
  platform: {
    name,
    release,
    target_id
  },
  version,
  statistics: {
    duration
  },
  profiles: [
    {
      name,
      version: GosecVersion,          // Version of GoSec instance
      sha256,
      title,
      maintainer,
      summary,
      license,
      copyright,
      copyright_email,
      supports,
      attributes,
      groups,
      controls: [
        {
          id: Issues.rule_id,         // ID of the requirement
          title: Issues.details,      // Human readable title for the requirement
          desc,
          descriptions,
          impact,
          refs,
          tags: {
            Issues.cwe                // Associated CWE for the requirement
            Issues.severity,          // Severity of the requirement
            Issues.confidence,        // Applicability of the requirement
            Issues.nosec,             // Whether to ignore the requirement
            Issues.suppressions       // Info suppression level of the requirement
          },
          code,
          source_location,
          results: [
            {
              status,
              code_desc: Issues.code, // The code for the requirement test
              message: {              // All materials describing where the issue occured
                Issues.file,
                Issues.line,
                Issues.column
              },
              run_time,
              start_time
            }
          ]
        },
      ],
      status
    },
  ],
  passthrough: {
    auxiliary_data: [
      {
        name,
        data
      },
    ],
    raw
  }
}
```
:::

::: details Remaining GoSec Source Data
```json
{
  // Purpose: Go compilation errors
  // Recording: Meta data - Not specifically related to the requirements and will be already recorded as a security issue in 'Issues' if critical
  "Golang errors": {},
  // Purpose: The statistics of the GoSec scan on the source code
  // Recording: Meta data - Info on the scan itself
  "Stats": {
    "files": 199,
    "lines": 12401,
    "nosec": 0,
    "found": 7
  }
}
```
:::

We map these fields to `message` in the OHDF schema as we can use these fields to create a verbose description of control test result. In particular, we use these fields to directly indicate to the reader where the test was performed and subsequently failed.

Next, let's look at the fields `Golang errors` and `Stats`.

::: details OHDF Schema Mapping Ver. 4
```typescript
{
  platform: {
    name,
    release,
    target_id
  },
  version,
  statistics: {
    duration
  },
  profiles: [
    {
      name,
      version: GosecVersion,          // Version of GoSec instance
      sha256,
      title,
      maintainer,
      summary,
      license,
      copyright,
      copyright_email,
      supports,
      attributes,
      groups,
      controls: [
        {
          id: Issues.rule_id,         // ID of the requirement
          title: Issues.details,      // Human readable title for the requirement
          desc,
          descriptions,
          impact,
          refs,
          tags: {
            Issues.cwe                // Associated CWE for the requirement
            Issues.severity,          // Severity of the requirement
            Issues.confidence,        // Applicability of the requirement
            Issues.nosec,             // Whether to ignore the requirement
            Issues.suppressions       // Info suppression level of the requirement
          },
          code,
          source_location,
          results: [
            {
              status,
              code_desc: Issues.code, // The code for the requirement test
              message: {              // All materials describing where the issue occured
                Issues.file,
                Issues.line,
                Issues.column
              },
              run_time,
              start_time
            }
          ]
        },
      ],
      status
    },
  ],
  passthrough: {
    auxiliary_data: [
      {                               // Go source data compilation errors
        name: 'Golang errors',
        data: Golang errors
      },
      {                               // Stats on GoSec scan
        name: 'Stats',
        data: Stats
      },
    ],
    raw
  }
}
```
:::

For these fields, we can place them in `passthrough` as there are no reasonably applicable fields in the OHDF schema to place them in.

Finally, let's fill the rest of the empty fields using what available information we can use, prioritizing required fields and omitting any applicable unrequired fields.

::: details OHDF Schema Mapping Ver. 5
```typescript
{
  platform: {                         // We fill in Heimdall for the platform as it handles the generation of this OHDF file
    name: 'Heimdall Tools',
    release: HeimdallToolsVersion
  },
  version: HeimdallToolsVersion,      // See 'platform' reasoning
  statistics: {},                     // Not enough info to fill
  profiles: [
    {
      name: 'Gosec scanner',          // We know that this report is generated from GoSec
      version: GosecVersion,          // Version of GoSec instance
      sha256: '',                     // Leave it empty as OHDF Converters will generate one for us
      title: 'gosec',                 // We know that this report is generated from GoSec
      supports: [],                   // Not enough info to fill
      attributes: [],                 // Not enough info to fill
      groups: [],                     // Not enough info to fill
      controls: [
        {
          id: Issues.rule_id,         // ID of the requirement
          title: Issues.details,      // Human readable title for the requirement
          desc: '',                   // Not enough info to fill
          impact: 0.5,                // Have no solid information on impact of security issue, so we default to 0.5
          refs: [],                   // Not enough info to fill
          tags: {
            Issues.cwe                // Associated CWE for the requirement
            Issues.severity,          // Severity of the requirement
            Issues.confidence,        // Applicability of the requirement
            Issues.nosec,             // Whether to ignore the requirement
            Issues.suppressions       // Info suppression level of the requirement
          },
          source_location: {},        // Not enough info to fill
          results: [
            {
              status: 'Failure',      // The security scan only reports failed requirements, so all findings we receive get fail statuses
              code_desc: Issues.code, // The code failing the requirement test
              message: {              // All materials describing where the issue occured
                Issues.file,
                Issues.line,
                Issues.column
              },
              start_time              // Not enough info to fill
            }
          ]
        },
      ],
      status: 'loaded'                // Give loaded status to denote that profile is loaded by OHDF Converters
    },
  ],
  passthrough: {
    auxiliary_data: [
      {                               // Go source data compilation errors
        name: 'Golang errors',
        data: Golang errors
      },
      {                               // Stats on GoSec scan
        name: 'Stats',
        data: Stats
      },
    ],
    raw
  }
}
```
:::

Now we have a finalized mapping for GoSec to OHDF.
