---
title: 15. Understanding Test Kitchen
author: Aaron Lippold
---

## Learning Objectives

By the end of this module, you will be able to:

- Understand the purpose and benefits of Test Kitchen
- Describe the Test Kitchen workflow
- Differentiate between vanilla and hardened configurations
- Execute basic Test Kitchen commands

## What is Test Kitchen?

Test Kitchen is a powerful testing framework that allows developers to test infrastructure code across different platforms and configurations. Think of it as a laboratory where you can safely experiment with different system configurations without affecting your production environment.

## Test Kitchen Workflow

The testing process follows four key stages:

1. **Create** ðŸ—ï¸
   - Spins up a fresh instance of your target platform
   - Sets up the basic environment

2. **Converge** ðŸ”„
   - Applies your infrastructure code
   - Configures the instance according to your specifications

3. **Verify** âœ…
   - Runs your tests against the instance
   - Checks if everything is configured correctly

4. **Destroy** ðŸ§¹
   - Cleans up the test environment
   - Removes the instance completely

## Testing Configurations

We use two main testing configurations:

### Vanilla Configuration

- Stock installation with default settings
- No customization or hardening
- Represents "out-of-the-box" state
- Used as a baseline for comparison

### Hardened Configuration

- Implements security best practices
- Follows benchmark recommendations (e.g., RHEL V1R12)
- Represents the target secure state
- Applied during the converge phase

```mermaid
flowchart TD
    Start([Test Kitchen Workflow]) --> Setup

    subgraph Setup["Phase 1: Setup"]
        S1[Checkout Repo]
        S2[Install Tools]
        S3[Setup Runner]
        S1 --> S2 --> S3
    end

    subgraph Configure["Phase 2: Configure Instances"]
        C1[Setup Vanilla Instance]
        C2[Setup Hardened Instance]
        C1 --> C2
    end

    subgraph Test["Phase 3: Run Tests"]
        T1[Test Vanilla]
        T2[Test Hardened]
        T1 --> T2
    end

    subgraph Record["Phase 4: Record Results"]
        R1[Save to Pipeline]
        R2[Upload to Heimdall]
        R1 --> R2
    end

    subgraph Validate["Phase 5: Validate Thresholds"]
        V1[Check Vanilla]
        V2[Check Hardened]
        V1 --> V2
    end

    Setup --> Configure
    Configure --> Test
    Test --> Record
    Record --> Validate
    Validate --> Decision{Pass?}
    Decision -->|No| Failed([Failed])
    Decision -->|Yes| Passed([Passed])
```

## Behind the Scenes: System Access

To enable testing, Test Kitchen makes minimal system modifications:

- Adds SSH private key authentication
- Sets up appropriate access protocols:
  - SSH for Unix/Linux systems
  - WinRM for Windows systems

## Where do we put it?

We put our Test Kitchen code that we use to assess our InSpec code in the same repository.  The example that we will be working through for the next few sections will use the [RHEL 9 InSpec repository](https://github.com/mitre/redhat-enterprise-linux-9-stig-baseline).
